<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no">
    <meta charset="utf-8">
    <title>Leaflet vs. Google Maps</title>
    <style>
      html, body {
        height: 100%;
        margin: 0px;
        padding: 0px
      }

      #google-maps-bw-map {

        width: 100%;
        height: 100%;
      }

    </style>
    <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
    <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.3/leaflet.css" />
    <script src="http://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.3/leaflet-src.js"></script>
    <script src="https://maps.googleapis.com/maps/api/js?v=3.exp&signed_in=true"></script>
    <script src="../lib/r360-src.js"></script>
    <!-- <script type="text/javascript" src="../../../lib/build/deps.js"></script>
    <script type="text/javascript" src="../../../lib/build/r360-include.js"></script> -->
    <script type="text/javascript">

        $(document).ready(function(){

            GoogleMapsPolygonLayer.prototype = new google.maps.OverlayView();

function GoogleMapsPolygonLayer(map, polygons, options) {

    // set default parameters
    this.map               = map;
    this.id                = this.map.getDiv().id
    this.inverse           = false;
    this.topRight          = { lat : -90, lng : -180 };
    this.bottomLeft        = { lat : -90, lng : +180 };
    this.multiPolygons     = [];//r360.PolygonUtil.prepareMultipolygons(polygons, this.topRight, this.bottomLeft);
    this.opacity           = r360.config.defaultPolygonLayerOptions.opacity;
    this.strokeWidth       = r360.config.defaultPolygonLayerOptions.strokeWidth;
    this.backgroundColor   = r360.config.defaultPolygonLayerOptions.backgroundColor,
    this.backgroundOpacity = r360.config.defaultPolygonLayerOptions.backgroundOpacity,
    this.tolerance         = r360.config.defaultPolygonLayerOptions.tolerance;
    this.extendWidthX      = r360.config.defaultPolygonLayerOptions.strokeWidth / 2;
    this.extendWidthY      = r360.config.defaultPolygonLayerOptions.strokeWidth / 2;

    // overwrite defaults with optional parameters
    if ( typeof options != 'undefined' ) {

        if ( typeof options.opacity        != 'undefined') this.opacity      = options.opacity;
        if ( typeof options.strokeWidth    != 'undefined') this.strokeWidth  = options.strokeWidth;
        if ( typeof options.inverse        != 'undefined') this.inverse      = options.inverse;
        if ( typeof options.tolerance      != 'undefined') this.tolerance    = options.tolerance;
        if ( typeof options.extendWidthX   != 'undefined') this.extendWidthX = options.extendWidthX;
        if ( typeof options.extendWidthY   != 'undefined') this.extendWidthY = options.extendWidthY;
    }

    // the div element containing all the data
    this.element  = null;
    // this triggers the draw method
    this.setMap(this.map);

    this.addListener();
}

/**
 * onAdd is called when the map's panes are ready and the overlay has been
 * added to the map.
 */
GoogleMapsPolygonLayer.prototype.onAdd = function() {

    // create the dom elemenet which hols old the svgs
    this.element    = document.createElement('div');
    this.element.id = 'r360-googlemaps-polygon-layer-canvas-in-' + this.id;

    // Add the element to the "overlayLayer" pane.
    this.getPanes().overlayLayer.appendChild(this.element);  
};

GoogleMapsPolygonLayer.prototype.getMapPixelBounds = function(){

    var bottomLeft = r360.Util.googleLatlngToPoint(this.map, this.map.getBounds().getSouthWest(), this.map.getZoom());
    var topRight   = r360.Util.googleLatlngToPoint(this.map, this.map.getBounds().getNorthEast(), this.map.getZoom());

    return { max : { x : topRight.x, y : bottomLeft.y }, min : { x : bottomLeft.x, y : topRight.y } }; 
};

GoogleMapsPolygonLayer.prototype.getPixelOrigin = function(){

    var viewHalf = r360.PolygonUtil.divide({ x : this.map.getDiv().offsetWidth, y : this.map.getDiv().offsetHeight }, 2);
    var center = r360.Util.googleLatlngToPoint(this.map, this.map.getCenter(), this.map.getZoom());
    
    return r360.PolygonUtil.roundPoint(r360.PolygonUtil.subtract(center, viewHalf.x, viewHalf.y));
};

GoogleMapsPolygonLayer.prototype.setInverse = function(inverse){

    console.log('inverse');
    if ( this.inverse != inverse ) {

        this.inverse = inverse;
        this.draw();
    }
};

GoogleMapsPolygonLayer.prototype.update = function(polygons){

    this.topRight          = { lat : -90, lng : -180 };
    this.bottomLeft        = { lat : -90, lng : +180 };
    this.multiPolygons     = r360.PolygonUtil.prepareMultipolygons(polygons, this.topRight, this.bottomLeft);
    
    this.setMap(this.map);
    // this.draw();
};

GoogleMapsPolygonLayer.prototype.createSvgData = function(polygon){

    var pixelBounds = r360.PolygonUtil.extendBounds(this.getMapPixelBounds(), this.extendWidthX, this.extendWidthY);

    var svg = r360.SvgUtil.createSvgData(polygon, { 
        bounds      : pixelBounds, 
        scale       : Math.pow(2, this.map.getZoom()) * 256, 
        tolerance   : this.tolerance, 
        pixelOrigin : this.getPixelOrigin(),  
        offset      : {x:0,y:0}
    });

    return svg;
};

GoogleMapsPolygonLayer.prototype.draw = function() {

    if ( this.multiPolygons.length > 0 ) {
             
        this.svgWidth  = this.map.getDiv().offsetWidth;
        this.svgHeight = this.map.getDiv().offsetHeight;

        // always place the layer in the top left corner. Later adjustments will be made by svg translate 
        r360.DomUtil.setPosition(this.element, { x : 0 , y : 0 });

        // calculate the offset in between map and svg in order to translate
        var svgPosition    = $('#svg_' + this.id).offset();
        var mapPosition    = $(this.map.getDiv()).offset();

        if ( typeof this.offset == 'undefined' )
            this.offset = { x : 0 , y : 0 };

        // adjust the offset after map panning / zooming
        if ( typeof svgPosition != 'undefined' ) {
            this.offset.x += (mapPosition.left - svgPosition.left);
            this.offset.y += (mapPosition.top  - svgPosition.top);
        }

        // clear layer from previous drawings
        $('#'+ this.element.id).empty();

        var gElements = [];  
        
        // go through each multipolygon (represents each travel time)
        for ( var i = 0 ; i < this.multiPolygons.length ;  i++){
            
            var multiPolygon = this.multiPolygons[i], svgData = [];

            // add each polygon for the given travel time
            for ( var j = 0; j < multiPolygon.polygons.length; j++) 
                svgData.push(this.createSvgData(multiPolygon.polygons[j]));

            if ( svgData.length != 0 ) 
                gElements.push(r360.SvgUtil.getGElement(svgData, {
                    color             : !this.inverse ? multiPolygon.getColor() : 'black',
                    opacity           : !this.inverse ? 1                       : multiPolygon.getOpacity(),
                    strokeWidth       : this.strokeWidth
                })); 
        }

        var options = {
            id                : this.id,
            offset            : this.offset,
            svgHeight         : this.svgHeight,
            svgWidth          : this.svgWidth,
            backgroundColor   : this.backgroundColor,
            backgroundOpacity : this.backgroundOpacity,
            opacity           : this.opacity,
            strokeWidth       : this.strokeWidth
        }

        // add the svg string to the container
        $('#'+ this.element.id).append(!this.inverse ? r360.SvgUtil.getNormalSvgElement(gElements, options) 
                                                     : r360.SvgUtil.getInverseSvgElement(gElements, options));
    }
};

GoogleMapsPolygonLayer.prototype.addListener = function() {

    var map = this.map;
    var that = this;

    google.maps.event.addListener(map, 'zoom_changed', function () {
        that.onRemove();
        google.maps.event.addListenerOnce(map, 'idle', function () {
            that.draw();
        });
    });

    google.maps.event.addListener(map, 'dragend', function () {
        google.maps.event.addListenerOnce(map, 'idle', function () {
            that.draw();
        });
    });
};

// The onRemove() method will be called automatically from the API if
// we ever set the overlay's map property to 'null'.
GoogleMapsPolygonLayer.prototype.onRemove = function() {
    $('#' + this.element.id).empty();
};

            var bwMap, marker = undefined;
            r360.config.serviceKey                                  = 'uhWrWpUhyZQy8rPfiC7X';
            // r360.config.serviceKey                                  = 'KRXn8oesiA4MNxrzMhJx';
            r360.config.serviceUrl                                  = 'http://dev.route360.net/api_denmark/';

            var bwPolygonLayer;

            function initGoogle() {

                bwMap = new google.maps.Map(document.getElementById('google-maps-bw-map'), { 
                    zoom: 11, center: new google.maps.LatLng(55.675298, 12.565125), mapTypeId: google.maps.MapTypeId.STREETS });

                bwPolygonLayer = new GoogleMapsPolygonLayer(bwMap, [], { inverse : true });

                google.maps.event.addListener(bwMap, 'click', function(event) {

                    if ( typeof marker !== 'undefined' ) marker.setMap(null);
                    if ( typeof bwPolygonLayer !== 'undefined' ) bwPolygonLayer.setMap(null);

                    marker = new google.maps.Marker({
                          position: event.latLng,
                          map: bwMap
                    });
                    showPolygons(event.latLng);
                });
            }

            function showPolygons(location) {

                var travelOptions = r360.travelOptions();
                travelOptions.addSource({ lat : location.lat(), lng : location.lng() });            
                travelOptions.setTravelTimes([3600]);
                travelOptions.setTravelType('transit');
                travelOptions.setDate('20150624');
                travelOptions.setTime('39000');
                var maxTravelTime = _.max(travelOptions.getTravelTimes());

                if ( maxTravelTime == 1200 || maxTravelTime == 2400 )
                    travelOptions.setMinPolygonHoleSize(10 * 1000 * 1000);
                if ( maxTravelTime == 3600 || maxTravelTime == 4800 )
                    travelOptions.setMinPolygonHoleSize(100 * 1000 * 1000);
                if ( maxTravelTime == 6000 || maxTravelTime == 7200 )
                    travelOptions.setMinPolygonHoleSize(1000 * 1000 * 1000);

                if ( r360.config.defaultPolygonLayerOptions.inverse ) 
                    travelOptions.setTravelTimes([_.max(travelOptions.getTravelTimes())]);
                
                // call the service
                r360.PolygonService.getTravelTimePolygons(travelOptions, function(polygons){
                    
                    bwPolygonLayer.update(polygons);
                });
            }

            initGoogle();
        });
    </script>
  </head>
  <body>
    <div id="google-maps-color-map"></div>
    <div id="google-maps-bw-map"></div>
    <div id="leaflet-color-map"></div>
    <div id="leaflet-bw-map"></div>
  </body>
</html>